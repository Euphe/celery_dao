# `docker-compose up` will show you the way

# Celery - асинхронные task-и на Python

Что тут происходит:

   * `celery_dao` содержит `python` проект
   
        *  проект описан через package, `setup.py` и `requirements.txt`
        *  проект состоит из двух "голов"
        * `celery_dao.__main__:main` запускает основное "приложение"
          * Все, что оно делает - запускает `celery`, подключается к `rabbitmq`, отправляет worker асинхронное задание (task): посчитать 2 + 2. Затем ждет, пока worker вернет результат, и выводит его.
        * `celery_dao.tasks` запускает `celery` worker
          * Worker ждет, пока кто-то отправит ему task. Выполняет задания по мере их поступления. Для демонстрации асинхронности задание сложения двух чисел занимает 10 секунд.
   *  `docker-compose` содержит описание сервисов и их взаимосвязей
        * `rabbitmq` это очередь сообщений, которую `celery` использует в качестве брокера. С помощью брокера `celery` хранит и транспортирует таски между сервисами. Т.е. брокер это шина для асинхронной передачи данных. Благодаря `celery` можно не заботится об устройстве брокера, хотя `RabbitMQ` можно использовать и без `celery`.
        * `dao` собирает приложение
          * Docker image собирается по инструкции из `Dockerfile`. Внутри устанавливаются зависимости из `requirements`, добавляется код модуля и `setup.py`, из `setup.py` модуль устанавливается в окружение. Таким образом проект можно запустить через описанный в `setup.py` `entry_point`, как консольную утилиту.
          * Весь код подставляется в контейнер как `volume`. Это позволяет редактировать код и видеть изменения без повторной сборки контейнера.
          * Связан с `rabbitmq` (`links`). Благодаря этому в коде можно использовать `rabbitmq` как имя хоста - докер создаст DNS запись и хост `rabbitmq` будет указывать на ip сервиса `rabbitmq`.
          * Запускается после worker, о чем свидетельствует `depends_on`       
        * `worker` запускает `celery` `worker`.
          * Использует тот же образ, что и `dao`. Нет нужды собирать образ два раза, ведь код один и тот же.
          * Исполняет команду, описанную в `docker-compose` как `command` для сервиса. Она более приоритетна, чем команда в `Dockerfile`.
          * Запускается после `rabbitmq`
          
Таким образом, 
1. `dao` отправляет `worker` запрос на долгое вычисление
2. `worker` обрабатывает запрос, возвращает результат
3. `dao` выводит результат
